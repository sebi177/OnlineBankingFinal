package com.example.onlinebankingfinal.model;

import com.example.onlinebankingfinal.model.enums.AccountStatus;
import com.example.onlinebankingfinal.model.enums.AccountType;
import com.example.onlinebankingfinal.model.enums.AgreementStatus;
import com.example.onlinebankingfinal.model.enums.CurrencyCode;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.sql.Timestamp;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.UUID;

/**
 * The Account class represents a bank account.
 * It contains information such as account ID, account name, account type, account status,
 * account balance, account currency code, creation timestamp, update timestamp, client details,
 * list of agreements associated with the account, and list of transactions associated with the account.
 */
@Entity
@Getter
@Setter
@NoArgsConstructor
@Table(name = "accounts")
public class Account {

    /**
     * Represents the unique identifier for an account.
     *
     * This variable is annotated with "@Id" to indicate that it is the primary key
     * column in the database table. It is also annotated with "@Column" to specify
     * the name of the corresponding column in the table.
     *
     * The value of this variable is generated automatically using a UUID
     * (Universally Unique Identifier) strategy, as specified by the
     * "@GeneratedValue" annotation.
     */
    @Id
    @Column(name = "account_id")
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID accountId;

    /**
     *
     */
    @Column(name = "account_name")
    private String accountName;

    /**
     * The account type of an account.
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "account_type")
    private AccountType accountType;

    /**
     * Represents the status of an account.
     * The possible values are:
     * - ACTIVE: The account is active and can be used for transactions.
     * - INACTIVE: The account is inactive and cannot be used for transactions.
     * - CLOSED: The account has been closed and can no longer be used.
     * - PENDING: The account is awaiting activation or approval.
     * - SUSPENDED: The account has been temporarily suspended and cannot be used.
     * - BLOCKED: The account has been blocked and cannot be used.
     * - DELETED: The account has been deleted and its data is no longer available.
     *
     * Possible values can be accessed through this enum type.
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "account_status")
    private AccountStatus accountStatus;

    /**
     * The account balance of an account.
     */
    @Column(name = "account_balance")
    private Double accountBalance;

    /**
     *
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "account_currency_code")
    private CurrencyCode accountCurrencyCode;

    /**
     * The createdAt variable represents the timestamp when an object was created.
     *
     * It is annotated with the @CreationTimestamp annotation, which indicates that the value of this field
     * will be automatically generated by the database when the object is persisted.
     *
     * The @Temporal(TemporalType.TIMESTAMP) annotation specifies that the value of this field will be stored as a timestamp in the database.
     *
     * The @Column(name = "created_at", updatable = false) annotation specifies that this field is mapped to a column named "created_at" in the database table.
     * The "updatable = false" attribute indicates that the value of this field will not be updated when the object is updated.
     *
     * The type of the createdAt variable is Timestamp, which represents a specific point in time.
     *
     * This variable is private, which means it can only be accessed within the class where it is declared.
     */
    @CreationTimestamp
    @Temporal(TemporalType.TIMESTAMP)
    @Column(name = "created_at", updatable = false)
    private Timestamp createdAt;

    /**
     *
     */
    @UpdateTimestamp
    @Temporal(TemporalType.TIMESTAMP)
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    /**
     * Represents the client associated with the account.
     *
     * The `Client` class contains information about the client such as their status, tax code, name, email, address,
     * phone, and password, as well as the date and time the client was created and updated. The client can have multiple
     * accounts and cards associated with them, and can also be associated with a manager. The `Client` class also
     * overrides the `equals()`, `hashCode()`, and `toString()` methods.
     *
     * Example usage:
     * Account account = new Account();
     * Client client = new Client();
     * account.setClient(client);
     *
     * Note: The above code snippet is for illustration purposes only and may not be syntactically correct.
     *
     * @see Account#getClient()
     * @see Client#getAccountList()
     * @see Client#getCardList()
     * @see Client#getManager()
     * @see Client#equals(Object)
     * @see Client#hashCode()
     * @see Client#toString()
     */
    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "client_id", referencedColumnName = "client_id")
    private Client client;

    /**
     * This variable holds a list of Agreement objects.
     *
     * The Agreement class represents a financial agreement between a client and a product.
     * Each Agreement object contains information such as the interest rate, agreement status, agreement sum,
     * creation timestamp, update timestamp, product, and account.
     *
     * The Account class represents a client's bank account and contains information such as the account ID,
     * account name, account type, account status, account balance, account currency code, creation timestamp,
     * update timestamp, client, agreement list, debit transaction list, and credit transaction list.
     *
     * The AgreementList variable is annotated with @OneToMany, indicating a one-to-many relationship between
     * the Account class and the Agreement class. The mappedBy attribute is set to "account", indicating that
     * the association is mapped by the "account" property in the Agreement class. The fetch attribute is set to
     * FetchType.EAGER, indicating that the association should be eagerly fetched.
     *
     * Other related classes include Client, CurrencyCode, AccountType, AccountStatus, AgreementStatus, Product, and Transaction.
     *
     * @see Agreement
     * @see Account
     * @see Client
     * @see CurrencyCode
     * @see AccountType
     * @see AccountStatus
     * @see AgreementStatus
     * @see Product
     * @see Transaction
     */
    @OneToMany(mappedBy = "account", fetch = FetchType.EAGER)
    private List<Agreement> agreementList;

    /**
     * Represents the debit transactions associated with an account.
     *
     * <p>
     * The debit transactions represent the transactions where money is withdrawn from the account.
     *
     * <p>
     * This variable is annotated with {@code @OneToMany} to indicate a one-to-many relationship
     * with the {@code Transaction} class. It is mapped by the {@code debitAccount} field in
     * the {@code Transaction} class.
     *
     * <p>
     * This variable is retrieved eagerly ({@code FetchType.EAGER}), meaning that when an account is
     * retrieved from the database, its associated debit transactions are also retrieved.
     */
    @OneToMany(mappedBy = "debitAccount", fetch = FetchType.EAGER)
    private Set<Transaction> debitTransaction;

    /**
     * This variable represents a set of credit transactions associated with an account.
     * It is a collection of Transaction objects that represent deposits, transfers, payments, etc.
     *
     * The transactions are fetched eagerly, meaning that they are loaded at the same time as the account that contains them.
     *
     * Example usage:
     *
     * Account account = new Account();
     * Set<Transaction> creditTransactions = new HashSet<>();
     * Transaction transaction1 = new Transaction();
     * // Set transaction properties
     * creditTransactions.add(transaction1);
     * account.setCreditTransaction(creditTransactions);
     *
     * Note: The Transaction class must be defined and imported for using this variable.
     */
    @OneToMany(mappedBy = "creditAccount", fetch = FetchType.EAGER)
    private Set<Transaction> creditTransaction;

    /**
     *
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Account account)) return false;
        return Objects.equals(accountId, account.accountId) && Objects.equals(accountName, account.accountName) && Objects.equals(accountBalance, account.accountBalance);
    }

    /**
     * Returns the hash code value for this Account object.
     *
     * The hash code is calculated based on the accountId, accountName, and accountBalance fields.
     *
     * @return the hash code value for this Account object
     */
    @Override
    public int hashCode() {
        return Objects.hash(accountId, accountName, accountBalance);
    }

    /**
     * Returns a string representation of the Account object.
     *
     * The returned string includes the account's ID, name, type, status, balance, currency code, creation date, and update date.
     *
     * @return a string representation of the Account object
     */
    @Override
    public String toString() {
        return "Account{" +
                "accountId=" + accountId +
                ", accountName='" + accountName + '\'' +
                ", accountType=" + accountType +
                ", accountStatus=" + accountStatus +
                ", accountBalance=" + accountBalance +
                ", accountCurrencyCode=" + accountCurrencyCode +
                ", createdAt=" + createdAt +
                ", updatedAt=" + updatedAt +
                '}';
    }

}
